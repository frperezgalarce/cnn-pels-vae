import socket
import datetime
import numpy as np
import pandas as pd
import matplotlib
if socket.gethostname() == 'exalearn':
    matplotlib.use('agg')
import matplotlib.pyplot as plt
import seaborn as sb
import matplotlib.cm as cm
from src.vae.vae_models import *
import wandb
import itertools
from typing import List
import logging
from matplotlib.ticker import MaxNLocator, FormatStrFormatter

with open('src/configuration/paths.yaml', 'r') as file:
    YAML_FILE = yaml.safe_load(file)

PATHS =YAML_FILE['paths']
PATH_LIGHT_CURVES_OGLE = PATHS['PATH_LIGHT_CURVES_OGLE']
PATH_FEATURES_TRAIN = PATHS['PATH_FEATURES_TRAIN']
PATH_FEATURES_TEST = PATHS['PATH_FEATURES_TEST']
PATH_NUMPY_DATA_X_TRAIN = PATHS['PATH_NUMPY_DATA_X_TRAIN']
PATH_NUMPY_DATA_X_TEST = PATHS['PATH_NUMPY_DATA_X_TEST'] 
PATH_NUMPY_DATA_Y_TRAIN = PATHS['PATH_NUMPY_DATA_Y_TRAIN']
PATH_NUMPY_DATA_Y_TEST = PATHS['PATH_NUMPY_DATA_Y_TEST'] 
PATH_SUBCLASSES = PATHS["PATH_SUBCLASSES"]
PATH_DATA_FOLDER = PATHS["PATH_DATA_FOLDER"]
PATH_FIGURES: str = PATHS['PATH_FIGURES']
PATH_MODELS: str = PATHS["PATH_MODELS"]
PATH_ZIP_GAIA:str = PATHS["PATH_ZIP_GAIA"]

# Create a wall of generated time series
def plot_wall_time_series(generated_lc, cls=[], data_real=None, color='vlue',
                          dim=(2, 4), figsize=(16, 4), title=None):
    """Light-curves wall plot, function used during VAE training phase.
    Figure designed and ready to be appended to W&B logger.

    Parameters
    ----------
    generated_lc : numpy array
        Array of generated light curves
    cls          : list, optional
        List of labels corresponding to the generated light curves.
    data_real    : numpy array, optional
        List of real light curves.
    dim          : list, optional
        Figure Nrows, Ncols.
    figsize      : list, optional
        Figure size
    title        : str, optional
        Figure title

    Returns
    -------
    fig
        a matplotlib figure
    image
        an image version of the figure
    """

    plt.close('all')
    if generated_lc.shape[2] == 3:
        use_time = True
        use_err = True
    elif generated_lc.shape[2] == 2:
        use_time = True
        use_err = False
    if generated_lc.shape[2] == 1:
        use_time = False
        use_err = False

    if len(cls) == 0:
        cls = [''] * (dim[0] * dim[1])
    fig, axis = plt.subplots(nrows=dim[0], ncols=dim[1], figsize=figsize)
    for i, ax in enumerate(axis.flat):
        if data_real is not None:
            ax.errorbar(data_real[i, :, 0],
                        data_real[i, :, 1],
                        yerr=data_real[i, :, 2],
                        fmt='.', c='gray', alpha=.5)
        if use_time and use_err:
            ax.errorbar(generated_lc[i, :, 0],
                        generated_lc[i, :, 1],
                        yerr=generated_lc[i, :, 2],
                        fmt='.', c='royalblue', label=cls[i])
        elif use_time and not use_err:
            ax.errorbar(generated_lc[i, :, 0],
                        generated_lc[i, :, 1], 
                        yerr=None,
                        fmt='.', c='royalblue', label=cls[i])
        elif not use_time and not use_err:
            ax.plot(generated_lc[i, :], '.',
                    c='royalblue', label=cls[i])
            
        ax.invert_yaxis()
        if cls[0] != '':
            ax.legend(loc='best')

    mytitle = fig.suptitle(title, fontsize=20, y=1.025)

    plt.tight_layout()
    fig.canvas.draw()
    image = np.frombuffer(fig.canvas.tostring_rgb(), dtype='uint8')
    image  = image.reshape(fig.canvas.get_width_height()[::-1] + (3,))
    return fig, image

def plot_latent_space(z, y=None):
    """Creates a joint plot of features, used during training, figures
    are W&B ready

    Parameters
    ----------
    z : numpy array
        fetures to be plotted
    y : list, optional
        axis for color code

    Returns
    -------
    fig
        matplotlib figure
    fig
        image of matplotlib figure
    """
    plt.close('all')
    df = pd.DataFrame(z)
    if y is not None:
        df.loc[:,'y'] = y
    pp = sb.pairplot(df,
                     hue='y' if y is not None else None,
                     hue_order=sorted(set(y)) if y is not None else None,
                     diag_kind="hist", markers=".", height=2,
                     plot_kws=dict(s=30, edgecolors='face', alpha=.8))

    plt.tight_layout()
    pp.fig.canvas.draw()
    image = np.frombuffer(pp.fig.canvas.tostring_rgb(), dtype='uint8')
    image  = image.reshape(pp.fig.canvas.get_width_height()[::-1] + (3,))
    return pp.fig, image

def plot_wall_lcs(lc_gen, lc_real, cls=[], lc_gen2=None, save=False, wandb_active=False, 
                to_title=None, sensivity=None, column_to_sensivity=None, all_columns=[]):
    """Creates a wall of light curves plot with real and reconstruction
    sequences, paper-ready.

    Parameters
    ----------
    lc_gen  : numpy array
        light curves generated by the VAE model
    lc_real : numpy array
        real light curves overlayed in the plot
    cls     : list, optional
        list with corresponding lables to be displayed as legends
    lc_gen2 : numpy array, optional
        array with second set of generated light curves if desired
    save    : bool, optional
        wheather to save or not the figure
        
    Returns
    -------
        display figure
    """

    #with open('models/' + reg_conf_file['model_parameters']['ID']+'_minmax_scaler.pkl', 'rb') as file:
    #    loaded_scaler = pickle.load(file)

    #original_data = loaded_scaler.inverse_transform(to_title.cpu().numpy())
    to_title_one = to_title[:,column_to_sensivity].cpu().numpy()
    to_title = to_title.cpu().numpy()

    if len(cls) == 0:
        cls = [''] * len(lc_gen)
    plt.close()
    fig, axis = plt.subplots(nrows=8, ncols=3, 
                             figsize=(16,14),
                             sharex=True, sharey=True)
    
    for i, ax in enumerate(axis.flat):
        ax.errorbar(lc_real[i, :, 0],
                    lc_real[i, :, 1],
                    fmt='.', c='gray', alpha=.5)

        ax.errorbar(lc_gen[i, :, 0],
                    lc_gen[i, :, 1], 
                    yerr=None,
                    fmt='.', c='royalblue', label=cls[i])
        if lc_gen2 is not None:
            ax.errorbar(lc_gen2[i, :, 0],
                        lc_gen2[i, :, 1], 
                        yerr=None,
                        fmt='.', c='g', alpha=.7)
        if cls[0] != '':
            ax.legend(loc='lower left')
        
        try:
            ax.text(0.05, 0.95, sensivity + ': ' + str(np.round(to_title_one[i],3)),
            verticalalignment='top', horizontalalignment='left',
            transform=ax.transAxes, fontsize=10)
        except Exception as error:
            logging.error(f"The light curve {lc} was not loaded: {error}")


    axis[-1,1].set_xlabel('Phase', fontsize=20)
    axis[4,0].set_ylabel('Normalized Magnitude', fontsize=20)
    #mytitle = fig.suptitle('', fontsize=20, y=1.05)
    if cls[0] != '':
        ax.legend(loc='lower left')
    

    title = ", ".join([f"{all_columns[i]}: {np.round(to_title[0, i], 2)}" 
                   for i in range(len(all_columns)) if i != column_to_sensivity])

    fig.suptitle(title, fontsize=20, y=0.9)
    fig.subplots_adjust(hspace=0, wspace=0)
    axis[0,0].invert_yaxis()
    print('saving: ', save)
    if save:
        feature = str(sensivity).replace('[', '').replace(']','').replace('_','').replace('/','')
        plt.savefig(PATH_FIGURES+'/recon_lc_'+reg_conf_file['model_parameters']['ID']+'_'+str(cls[0])+'_'+feature+'.pdf', format='pdf', bbox_inches='tight')
    if wandb_active:
        wandb.init(project="cnn-pelsvae")
        wandb.log({"test": plt})
        wandb.finish()
    else: 
        plt.show()
    return 

def plot_wall_lcs_sampling(lc_gen, lc_real, cls=[], lc_gen2=None, save=True, wandb_active=False, 
                to_title=None, sensivity=None, all_columns=[], plot_title=False):
    """Creates a wall of light curves plot with real and reconstruction
    sequences, paper-ready.

    Parameters
    ----------
    lc_gen  : numpy array
        light curves generated by the VAE model
    lc_real : numpy array
        real light curves overlayed in the plot
    cls     : list, optional
        list with corresponding lables to be displayed as legends
    lc_gen2 : numpy array, optional
        array with second set of generated light curves if desired
    save    : bool, optional
        wheather to save or not the figure
        
    Returns
    -------
        display figure
    """

    #with open('models/' + reg_conf_file['model_parameters']['ID']+'_minmax_scaler.pkl', 'rb') as file:
    #    loaded_scaler = pickle.load(file)

    #original_data = loaded_scaler.inverse_transform(to_title.cpu().numpy())
    to_title = to_title.cpu().numpy()

    
    if len(cls) == 0:
        cls = [''] * len(lc_gen)
    plt.close()
    fig, axis = plt.subplots(nrows=5, ncols=1, 
                             figsize=(5,12),
                             sharex=False, sharey=False)
    
    for i, ax in enumerate(axis.flat):
        print(", ".join([f"{all_columns[j]}: {np.round(to_title[i, j], 2)}" for j in range(len(all_columns))]))

        ax.errorbar(lc_real[i, :, 0],
                    lc_real[i, :, 1],
                    fmt='.', c='gray', alpha=.5)

        ax.errorbar(lc_gen[i, :, 0],
                    lc_gen[i, :, 1], 
                    yerr=None,
                    fmt='.', c='royalblue', label=cls[i])
        if lc_gen2 is not None:
            ax.errorbar(lc_gen2[i, :, 0],
                        lc_gen2[i, :, 1], 
                        yerr=None,
                        fmt='.', c='g', alpha=.7)
        if cls[0] != '':
            ax.legend(loc='lower left')
        
        try:
            if plot_title:
                title = ", ".join([f"{all_columns[j]}: {np.round(to_title[i, j], 2)}" 
                    for j in range(len(all_columns))])

                ax.text(0.05, 0.95, title,
                verticalalignment='top', horizontalalignment='left',
                transform=ax.transAxes, fontsize=6)
        except Exception as error:
            logging.error(f"The light curve was not loaded: {error}")


    axis[4].set_xlabel('Phase', fontsize=12)

    for ax_i in [0, 1, 2, 3, 4]:
        axis[ax_i].set_ylabel('Norm Magnitude', fontsize=12)
        axis[ax_i].tick_params(axis='y', labelcolor='royalblue')
        axis[ax_i].xaxis.set_major_locator(MaxNLocator(4))
        axis[ax_i].yaxis.set_major_locator(MaxNLocator(4))
        axis[ax_i].xaxis.set_major_formatter(FormatStrFormatter('%.1f'))
        axis[ax_i].yaxis.set_major_formatter(FormatStrFormatter('%.1f'))

    #mytitle = fig.suptitle('', fontsize=20, y=1.05)
    if cls[0] != '':
        ax.legend(loc='lower left')

    #title = " Epoch"

    #fig.suptitle(title, fontsize=20, y=0.9)
    #fig.subplots_adjust(hspace=0, wspace=0)
    axis[0].invert_yaxis()
    axis[1].invert_yaxis()
    axis[2].invert_yaxis()
    axis[3].invert_yaxis()
    axis[4].invert_yaxis()
    print('saving: ', save)
    
    if save:
        #figure_id_df = pd.DataFrame([0], columns=['figure_id'])
        #figure_id_df.to_csv('figure_id.csv') 
        figure_id_df = pd.read_csv('figure_id.csv', index_col=None)
        figure_id = figure_id_df.figure_id.max() 
        feature = str(sensivity).replace('[', '').replace(']','').replace('_','').replace('/','')
        plt.savefig(PATH_FIGURES+'/epoch_recon_lc_'+str(cls[0])+'_'+feature+'_ID_'+str(figure_id)+'.png', format='png')
        plt.show()
    if wandb_active:
        wandb.log({"epochs": wandb.Image(plt)})
    else: 
        plt.show()
    return 'done'

def plot_batch(df1, df1y, label_encoder):

    for i in range(int(np.max(df1y)) + 1):  # Ensure all classes are covered
        
        plt.figure(figsize=(12, 8))
        
        # Dataset 1
        mask1 = df1y[:, i] == 1
        delta_time1 = df1[mask1][:, 0, :].ravel()
        delta_magnitude1 = df1[mask1][:, 1, :].ravel()
        
        # Class name
        class_name = label_encoder.inverse_transform([i])[0]

        # Plot 2D scatter for Dataset 1
        sb.scatterplot(x=delta_time1, y=delta_magnitude1, color="r", label="Synthetic Light curves", alpha=0.2)
        
        plt.title(f"2D Density for Class {class_name}")
        plt.legend()
        plt.savefig(f"2D_Density_Class_{class_name}.png")
        plt.show()

def scatter_hue(x, y, labels, disc=True, c_label=''):
    """Creates a wall of light curves plot with real and reconstruction
    sequences, paper-ready.

    Parameters
    ----------
    x      : array
        data to be plotted in horizontal axis
    y      : array
        data to be plotted in vertical axis
    labels : list, optional
        list with corresponding lables to be displayed as legends
    disc : bool, optional
        wheather the axis used for coloring is discrete or not
    c_label    : bool, optional
        name of color dimension
        
    Returns
    -------
        display figure
    """
    
    fig = plt.figure(figsize=(12,9))
    if disc:
        c = cm.Dark2_r(np.linspace(0,1,len(set(labels))))
        for i, cls in enumerate(set(labels)):
            idx = np.where(labels == cls)[0]
            plt.scatter(x[idx], y[idx], marker='.', s=20,
                        color=c[i], alpha=.7, label=cls)
    else:
        plt.scatter(x, y, marker='.', s=20,
                    c=labels, cmap='coolwarm_r', alpha=.7)
        plt.colorbar(label=c_label)
        
    plt.xlabel('embedding 1')
    plt.ylabel('embedding 2')
    plt.legend(loc='best', fontsize='x-large')
    plt.show()

def plot_cm(cm: np.ndarray,
            labels: List[str],
            title: str = 'Confusion Matrix',
            save: bool = True,
            filename: Optional[str] = None,
            normed: bool = True, 
            wandb_active: bool = True) -> None:
    """
    Plots a confusion matrix using Matplotlib.

    Parameters:
    -----------
    cm : np.ndarray
        The confusion matrix to be plotted.
    labels : List[str]
        List of class labels for annotation.
    title : str, optional
        Title of the plot. Default is 'Confusion Matrix'.
    save : bool, optional
        Whether to save the plot to a file. Default is False.
    filename : str, optional
        File name for saving the plot. If None, a default name will be generated. 
        Default is None.
    normed : bool, optional
        Whether to normalize the values. Default is False.

    Returns:
    --------
    None
    """
    
    plt.figure(figsize=(8, 8))
    plt.imshow(cm, cmap=plt.cm.Blues)
    plt.title(title)
    plt.colorbar()
    plt.xlabel('Predicted label')
    plt.ylabel('True label')
    
    thresh = cm.max() / 2
    
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        if normed:
            value = int(np.round(cm[i, j], 2) * 100)  # Convert float to integer
        else:
            value = int(np.round(cm[i, j], 2))
        
        plt.text(j, i, format(value, 'd'),
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")
        
    plt.xticks(range(len(labels)), labels)
    plt.yticks(range(len(labels)), labels)
    
    plt.tight_layout()
    
    if save:
        if filename is None:
            current_date = datetime.datetime.now().strftime('%Y%m%d')
            title_formatted = title.replace(' ', '_')
            filename = f"{title_formatted}_confusion_matrix_{current_date}.png"
        plt.savefig(filename)

        if wandb_active: 
            wandb.log({title: wandb.Image(plt)})

    else:
        plt.show()